import { Injectable, NotFoundException, Logger } from '@nestjs/common';
import { PrismaService } from '../common/prisma/prisma.service';

/**
 * 学习路径服务
 */
@Injectable()
export class LearningPathsService {
  private readonly logger = new Logger(LearningPathsService.name);

  constructor(private prisma: PrismaService) {}

  /**
   * 创建学习路径
   */
  async createLearningPath(userId: string, name: string, description?: string, difficulty?: number) {
    const learningPath = await this.prisma.learningPath.create({
      data: {
        userId,
        name,
        description,
        difficulty: difficulty || 1,
        progress: 0,
      },
    });

    this.logger.log(`Learning path created: ${learningPath.id} by user ${userId}`);
    return learningPath;
  }

  /**
   * 获取用户的所有学习路径
   */
  async getUserLearningPaths(userId: string) {
    const paths = await this.prisma.learningPath.findMany({
      where: { userId },
      include: {
        _count: {
          select: { resources: true },
        },
      },
      orderBy: { updatedAt: 'desc' },
    });

    return paths;
  }

  /**
   * 获取学习路径详情
   */
  async getLearningPath(pathId: string, userId: string) {
    const path = await this.prisma.learningPath.findFirst({
      where: {
        id: pathId,
        userId,
      },
      include: {
        resources: {
          include: {
            resource: true,
          },
          orderBy: { order: 'asc' },
        },
      },
    });

    if (!path) {
      throw new NotFoundException('Learning path not found');
    }

    return path;
  }

  /**
   * 添加资源到学习路径
   */
  async addResourceToPath(pathId: string, resourceId: string, userId: string, order?: number) {
    // 验证路径归属
    const path = await this.prisma.learningPath.findFirst({
      where: {
        id: pathId,
        userId,
      },
    });

    if (!path) {
      throw new NotFoundException('Learning path not found');
    }

    // 如果没有指定顺序，放到最后
    if (order === undefined) {
      const lastResource = await this.prisma.learningPathResource.findFirst({
        where: { pathId },
        orderBy: { order: 'desc' },
      });
      order = (lastResource?.order || 0) + 1;
    }

    // 添加资源
    await this.prisma.learningPathResource.create({
      data: {
        pathId,
        resourceId,
        order,
        completed: false,
      },
    });

    // 更新路径的更新时间
    await this.prisma.learningPath.update({
      where: { id: pathId },
      data: { updatedAt: new Date() },
    });

    this.logger.log(`Resource ${resourceId} added to learning path ${pathId}`);

    return { message: 'Resource added to learning path' };
  }

  /**
   * 标记资源为完成
   */
  async markResourceAsCompleted(pathId: string, resourceId: string, userId: string) {
    // 验证路径归属
    const path = await this.prisma.learningPath.findFirst({
      where: {
        id: pathId,
        userId,
      },
    });

    if (!path) {
      throw new NotFoundException('Learning path not found');
    }

    // 标记为完成
    await this.prisma.learningPathResource.updateMany({
      where: {
        pathId,
        resourceId,
      },
      data: {
        completed: true,
        completedAt: new Date(),
      },
    });

    // 重新计算进度
    await this.updatePathProgress(pathId);

    this.logger.log(`Resource ${resourceId} marked as completed in path ${pathId}`);

    return { message: 'Resource marked as completed' };
  }

  /**
   * 更新学习路径进度
   */
  private async updatePathProgress(pathId: string) {
    const resources = await this.prisma.learningPathResource.findMany({
      where: { pathId },
    });

    if (resources.length === 0) {
      return;
    }

    const completedCount = resources.filter((r) => r.completed).length;
    const progress = Math.round((completedCount / resources.length) * 100);

    await this.prisma.learningPath.update({
      where: { id: pathId },
      data: { progress },
    });
  }

  /**
   * 删除学习路径
   */
  async deleteLearningPath(pathId: string, userId: string) {
    const path = await this.prisma.learningPath.findFirst({
      where: {
        id: pathId,
        userId,
      },
    });

    if (!path) {
      throw new NotFoundException('Learning path not found');
    }

    await this.prisma.learningPath.delete({
      where: { id: pathId },
    });

    this.logger.log(`Learning path ${pathId} deleted`);

    return { message: 'Learning path deleted' };
  }

  /**
   * 更新学习路径
   */
  async updateLearningPath(
    pathId: string,
    userId: string,
    name?: string,
    description?: string,
    difficulty?: number,
  ) {
    const path = await this.prisma.learningPath.findFirst({
      where: {
        id: pathId,
        userId,
      },
    });

    if (!path) {
      throw new NotFoundException('Learning path not found');
    }

    const updated = await this.prisma.learningPath.update({
      where: { id: pathId },
      data: {
        ...(name && { name }),
        ...(description !== undefined && { description }),
        ...(difficulty && { difficulty }),
        updatedAt: new Date(),
      },
    });

    return updated;
  }
}
